<!doctype html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <title>Minimal ApexCharts rangeBar with clickable points (fixed tooltip)</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <script src="https://cdn.jsdelivr.net/npm/apexcharts"></script>
  <style>
    body { font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial; padding: 20px; }
    .card { border: 1px solid #ddd; border-radius: 6px; padding: 12px; max-width: 900px; }
    .chart { height: 360px; }
    .spinner-wrapper { position: absolute; left: 50%; top: 50%; transform: translate(-50%, -50%); }
        /* make bars pointer so user knows they are clickable */
    .apexcharts-series .apexcharts-bar-area { cursor: pointer; }

    /* clickable y-axis label styling */
    #chart-canvas .apexcharts-yaxis .clickable-label {
      cursor: pointer;
      text-decoration: underline;
    }
    #chart-canvas .apexcharts-yaxis .clickable-label:focus {
      outline: 2px solid #2684FF;
      outline-offset: 2px;
    }
    .apexcharts-tooltip-range a { color: #2684FF; text-decoration: underline; }
  </style>
</head>
<body>

  <div id="rangebar-1" class="card" data-pre-init="chart">
    <h3 class="card-title">{{title}}</h3>

    <div class="chart">
      <div id="chart-canvas"></div>
      <div class="spinner-wrapper" id="spinner">
        Loading...
      </div>

      <!-- Inline JSON data. The last item in each point row is the link (or null). -->
<data hidden>
{
  "type": {{stringify type}},
  "time": {{stringify time}},
  "labels": {{stringify labels}},
  "marker": {{stringify marker}},
  "xtitle": {{stringify xtitle}},
  "ytitle": {{stringify ytitle}},
  "ztitle": {{stringify ztitle}},
  "xticks": {{stringify xticks}},
  "yticks": {{stringify yticks}},
  "ystep": {{stringify ystep}},
  "xmin": {{stringify xmin}},
  "ymin": {{stringify ymin}},
  "xmax": {{stringify xmax}},
  "ymax": {{stringify ymax}},
  "toolbar": {{stringify toolbar}},
  "logarithmic": {{stringify logarithmic}},
  "horizontal": {{stringify horizontal}},
  "stacked": {{stringify stacked}},
  "height": {{stringify (default height 250)}},
  "colors": {{stringify (to_array color)}},
  "points":
     [
      {{~#each_row~}}
        {{~#if (gt @row_index 0)}},{{/if~}}
        [
            {{~ stringify (default series (default ../title "")) ~}},
            {{~ stringify (default x label) ~}},
            {{~ stringify (default y value) ~}}
            {{~#if z}}, {{~ stringify z ~}} {{~/if~}}
            {{~#if link}}, {{~ stringify link ~}} {{~/if~}}
        ]
    {{~/each_row~}}
    ]
        }
      </data>
    </div>
  </div>

<script>
(function(){
  const container = document.querySelector('[data-pre-init="chart"]');
  if (!container) return;

  const dataEl = container.querySelector("data");
  if (!dataEl) return;

  // decode HTML entities if present
  let raw = dataEl.textContent || "";
  if (raw.includes("&")) {
    const txt = document.createElement("textarea");
    txt.innerHTML = raw;
    raw = txt.value;
  }

  let chartData;
  try {
    chartData = JSON.parse(raw);
  } catch (e) {
    console.error("Failed to parse chart data JSON:", e, raw);
    return;
  }

  const rawPoints = Array.isArray(chartData.points) ? chartData.points : [];
  const looksLikeLink = (val) => typeof val === "string" && (/(^https?:\/\/)/i.test(val.trim()) || /^\//.test(val.trim()) || /^mailto:/i.test(val.trim()));

  const seriesNames = [];
  const seriesMap = {}; // { seriesName: { dataByX: {}, linksByX: {} } }
  const categories = [];

  const toMs = (d) => {
    if (typeof d === "number") return d;
    if (d === null || d === undefined || d === "") return null;
    if (/^\d+$/.test(String(d).trim())) return Number(d);
    const s = String(d).trim();
    // If string already contains time, keep it, otherwise append midnight
    const dt = new Date(s.includes("T") ? s : `${s}T00:00:00`);
    if (isNaN(dt)) return null;
    return dt.getTime();
  };

  // Accept rows: [seriesName, x, y, (maybe other), linkIsLast]
  rawPoints.forEach(pt => {
    if (!Array.isArray(pt) || pt.length < 3) return;
    const seriesName = pt[0];
    const xRaw = pt[1];
    const yRaw = pt[2];
    const linkRaw = pt[pt.length - 1];

    // Convert x to ms when possible. If conversion fails, keep original x (string/category).
    const xMs = toMs(xRaw);
    // Use the numeric ms when possible so Apex's datetime xaxis works correctly.
    const xKey = (xMs !== null) ? xMs : xRaw;

    let y;
    if (Array.isArray(yRaw)) {
      // Range y: convert each item to ms
      const conv = yRaw.map(item => toMs(item));
      y = conv.every(v => v !== null) ? conv : null;
    } else {
      const m = toMs(yRaw);
      y = (m !== null) ? m : null;
    }

    const link = looksLikeLink(linkRaw) ? String(linkRaw).trim() : null;

    // Ensure categories keep the same representation used as keys (string/number)
    // Use strict equality check on existing entries to avoid duplicates for same ms value
    if (!categories.some(c => String(c) === String(xKey))) categories.push(xKey);
    if (!seriesNames.includes(seriesName)) seriesNames.push(seriesName);

    if (!seriesMap[seriesName]) seriesMap[seriesName] = { dataByX: {}, linksByX: {} };
    // use string keys internally for object lookups
    const mapKey = String(xKey);
    seriesMap[seriesName].dataByX[mapKey] = y;
    if (link) seriesMap[seriesName].linksByX[mapKey] = link;
  });

  // Build ApexCharts series format
  const series = seriesNames.map(name => ({
    name,
    data: categories.map(cat => {
      const mapKey = String(cat);
      const y = seriesMap[name].dataByX?.[mapKey] ?? null;
      // Use the original cat value (number or string) for x so datetime axis works if it's numeric
      return { x: (typeof cat === "string" && /^\d+$/.test(cat)) ? Number(cat) : cat, y: y };
    })
  }));

  // Link lookup by "seriesIndex:dataPointIndex"
  const linksLookup = {};
  series.forEach((s, sIdx) => {
    s.data.forEach((dObj, i) => {
      const mapKey = String(dObj.x);
      const linkForPoint = seriesMap[s.name].linksByX?.[mapKey];
      if (linkForPoint) linksLookup[`${sIdx}:${i}`] = linkForPoint;
    });
  });

  const formatDateValue = (val) => {
    // val may be number (ms), ISO string, or array [startMs, endMs]
    const fmt = (ms) => {
      const d = new Date(ms);
      if (isNaN(d)) return String(ms);
      return d.toLocaleDateString(undefined, { year: "numeric", month: "numeric", day: "numeric" });
    };
    if (Array.isArray(val)) {
      return val.map(v => fmt(v)).join(" — ");
    }
    if (typeof val === "number") return fmt(val);
    // try parsing string
    const maybeMs = toMs(val);
    if (maybeMs !== null) return fmt(maybeMs);
    return String(val);
  };

// Attach click/keyboard handlers to Y-axis label elements.
  // Robust: tries to find per-label <g> groups, falls back to text nodes.
  function attachLabelLinks() {
    if (!chartContainer) return;

    // Prefer the per-label <g> nodes for y-axis text (one g per label)
    let labelGroups = chartContainer.querySelectorAll('.apexcharts-yaxis .apexcharts-yaxis-texts-g > g');

    let fallbackToText = false;
    if (!labelGroups || labelGroups.length === 0) {
      const textNodes = chartContainer.querySelectorAll('.apexcharts-yaxis text');
      if (!textNodes || textNodes.length === 0) return;
      fallbackToText = true;
      labelGroups = textNodes;
    }

    labelGroups.forEach((groupEl, idx) => {
      // get matching data point by index
      const pt = dataPoints[idx];
      const link = pt && pt.link ? pt.link : null;

      // Determine element that receives events: prefer group's inner text element if present
      let textEl = groupEl;
      if (!fallbackToText && groupEl.querySelector) {
        const innerText = groupEl.querySelector('text');
        if (innerText) textEl = innerText;
      }

      // Clear previous handlers / attributes if no link
      if (!link) {
        textEl.classList.remove('clickable-label');
        textEl.style.cursor = '';
        textEl.style.fill = '';
        textEl.removeAttribute('role');
        textEl.removeAttribute('tabindex');
        // remove handlers (setting to null is simple and avoids needing to track references)
        try { groupEl.onclick = null; } catch (e) {}
        try { groupEl.onkeydown = null; } catch (e) {}
        try { textEl.onclick = null; } catch (e) {}
        try { textEl.onkeydown = null; } catch (e) {}
        return;
      }

      textEl.classList.add('clickable-label');
      textEl.style.cursor = 'pointer';
      textEl.style.fill = '#0366d6';
      textEl.setAttribute('role', 'link');
      textEl.setAttribute('tabindex', '0');

      // handler functions (assigned directly to properties to ensure single binding)
      const clickHandler = function(evt) {
        if (evt && typeof evt.preventDefault === 'function') evt.preventDefault();
        if (evt && typeof evt.stopPropagation === 'function') evt.stopPropagation();
        if (evt && typeof evt.stopImmediatePropagation === 'function') evt.stopImmediatePropagation();
        openLinkInNewTab(link);
      };
      const keyHandler = function(evt) {
        if (evt.key === 'Enter' || evt.key === ' ') {
          if (evt && typeof evt.preventDefault === 'function') evt.preventDefault();
          if (evt && typeof evt.stopPropagation === 'function') evt.stopPropagation();
          openLinkInNewTab(link);
        }
      };

      // assign handlers to both group and text nodes for robustness
      try { groupEl.onclick = clickHandler; } catch (e) {}
      try { groupEl.onkeydown = keyHandler; } catch (e) {}
      try { textEl.onclick = clickHandler; } catch (e) {}
      try { textEl.onkeydown = keyHandler; } catch (e) {}
    });
  }
  
  const options = {
    chart: {
      type: chartData.type || 'rangeBar',
      height: chartData.height || 360,
      toolbar: { show: false },
    events: {
      dataPointSelection: function(event, chartContext, config) {
        const key = `${config.seriesIndex}:${config.dataPointIndex}`;
        const link = linksLookup[key];
        if (!link) return;

        // Si la fonction openInSqlpageModal existe, l’utiliser pour ouvrir dans la popup
        if (typeof window.openInSqlpageModal === "function") {
          event.preventDefault?.();
          event.stopPropagation?.();
          window.openInSqlpageModal(link);
        } else {
          // fallback : nouvelle fenêtre
          window.open(link, "_blank", "noopener");
        }
      }
    }
    },
    plotOptions: {
      bar: {
        horizontal: chartData.horizontal || false,
        dataLabels: { position: "top" }
      }
    },
    series: series,
    xaxis: {
      // If categories are numeric timestamps, use datetime; otherwise chart will still accept strings.
      type: "datetime",
      labels: {
        format: "dd / MM / yy"
      }
    },
    tooltip: {
      x: {
        show: true,
        formatter: function(value) {
          // value may be number (timestamp) or string or an array in case of range
          return formatDateValue(value);
        }
      }
    },
    colors: chartData.colors || undefined
  };

  const chartContainer = document.getElementById("chart-canvas");
  const spinner = document.getElementById("spinner");
  const chart = new ApexCharts(chartContainer, options);
  chart.render()
    .then(() => { if (spinner) spinner.remove(); })
    .catch(err => console.error("ApexCharts render error:", err));
})();
</script>
</body>
</html>